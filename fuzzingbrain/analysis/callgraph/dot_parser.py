"""
DOT File Parser for SVF Call Graphs

Parses DOT files generated by SVF wpa tool.
Based on legacy parse_callgraph.py
"""

import re
from pathlib import Path
from typing import Dict, Set, List, Optional
from dataclasses import dataclass, field
from collections import defaultdict


@dataclass
class CallGraph:
    """
    Call graph representation.

    Attributes:
        edges: Dict mapping caller -> set of callees
        nodes: Set of all function names
    """
    edges: Dict[str, Set[str]] = field(default_factory=lambda: defaultdict(set))
    nodes: Set[str] = field(default_factory=set)

    def add_edge(self, caller: str, callee: str):
        """Add a call edge from caller to callee"""
        self.edges[caller].add(callee)
        self.nodes.add(caller)
        self.nodes.add(callee)

    def get_callees(self, func_name: str) -> Set[str]:
        """Get all functions called by func_name"""
        return self.edges.get(func_name, set())

    def get_callers(self, func_name: str) -> Set[str]:
        """Get all functions that call func_name"""
        callers = set()
        for caller, callees in self.edges.items():
            if func_name in callees:
                callers.add(caller)
        return callers

    def to_dict(self) -> Dict[str, List[str]]:
        """Convert to dict for JSON serialization"""
        return {k: sorted(v) for k, v in self.edges.items()}

    def __len__(self) -> int:
        return len(self.nodes)


def canonical_name(func_name: str) -> str:
    """
    Normalize function names.
    Convert "OSS_FUZZ_png_read_info" to "png_read_info".
    """
    if func_name.startswith("OSS_FUZZ_"):
        return func_name[9:]
    return func_name


def parse_dot_file(dot_path: Path) -> CallGraph:
    """
    Parse a DOT file generated by SVF wpa.

    Supports two formats:
    - Old: Node0x[hex] with PTACallGraphNode labels
    - New: Node[num] with simple labels

    Args:
        dot_path: Path to the DOT file

    Returns:
        CallGraph object with parsed edges
    """
    graph = CallGraph()
    node_names: Dict[str, str] = {}

    with open(dot_path, "r") as f:
        content = f.read()

    # Pattern 1: Old SVF format
    # Node0x[hex] [shape=...,label="{PTACallGraphNode ID: digits {fun: SomeFunc}"]
    node_pattern_old = re.compile(
        r'Node0x([a-f0-9]+)\s+\[shape=.*?label="{PTACallGraphNode ID: \d+ \\{fun: ([^}]+)\\}'
    )

    # Pattern 2: New format
    # Node[number] [shape=Mrecord,label="FunctionName"]
    node_pattern_new = re.compile(r'Node(\d+)\s+\[.*?label="([^"]+)"')

    # Try old pattern first
    matches_old = list(node_pattern_old.finditer(content))
    if matches_old:
        for m in matches_old:
            node_id = m.group(1)
            raw_name = m.group(2)

            # Clean up name
            if "\\n" in raw_name:
                raw_name = raw_name.split("\\n", 1)[0]
            if "{fun:" in raw_name:
                subm = re.search(r'\\{fun:\s*([^}]+)\\}', raw_name)
                if subm:
                    raw_name = subm.group(1)

            node_names[node_id] = canonical_name(raw_name)
    else:
        # Try new pattern
        matches_new = list(node_pattern_new.finditer(content))
        for m in matches_new:
            node_id = m.group(1)
            raw_name = m.group(2)
            if "\\n" in raw_name:
                raw_name = raw_name.split("\\n", 1)[0]
            node_names[node_id] = canonical_name(raw_name)

    # Parse edges
    # Old format: Node0x[hex]:s[num] -> Node0x[hex]
    edge_pattern_old = re.compile(r'Node0x([a-f0-9]+):s\d+\s+->\s+Node0x([a-f0-9]+)')
    # New format: Node[num] -> Node[num]
    edge_pattern_new = re.compile(r'Node(\d+)\s*->\s*Node(\d+)')

    matches_edge_old = list(edge_pattern_old.finditer(content))
    if matches_edge_old:
        for m in matches_edge_old:
            src_id = m.group(1)
            dst_id = m.group(2)
            if src_id in node_names and dst_id in node_names:
                graph.add_edge(node_names[src_id], node_names[dst_id])
    else:
        matches_edge_new = list(edge_pattern_new.finditer(content))
        for m in matches_edge_new:
            src_id = m.group(1)
            dst_id = m.group(2)
            if src_id in node_names and dst_id in node_names:
                graph.add_edge(node_names[src_id], node_names[dst_id])

    # Add all nodes (some might have no edges)
    for name in node_names.values():
        graph.nodes.add(name)

    return graph
