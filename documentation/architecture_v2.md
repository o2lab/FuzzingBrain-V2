# FuzzingBrain: 基于大语言模型的自动化漏洞发现系统

---

## 摘要

本文介绍 FuzzingBrain，一个结合大语言模型（LLM）与模糊测试技术的自动化漏洞发现系统。与传统模糊测试工具依赖随机变异或覆盖率引导不同，FuzzingBrain 引入"可疑点"（Suspicious Point）这一中间抽象层，通过 LLM 驱动的多智能体协作，实现对代码的语义级漏洞分析。系统采用两级函数池设计和三阶段分析流程，在保证分析深度的同时最大化代码覆盖率。实验表明，FuzzingBrain 能够在多个开源项目中发现传统工具难以触及的深层漏洞。

**关键词**：模糊测试、大语言模型、漏洞发现、程序分析、智能体系统

---

## 1. 引言

### 1.1 研究背景

软件安全漏洞是网络安全领域的核心挑战。模糊测试（Fuzzing）作为一种自动化漏洞发现技术，通过向目标程序注入大量随机或半随机输入来触发异常行为，已在工业界得到广泛应用。然而，传统模糊测试面临两个根本性限制：

第一，**语义盲目性**。覆盖率引导的模糊测试器（如 AFL、LibFuzzer）虽然能够有效探索程序路径，但对代码的语义含义缺乏理解。它们无法区分"安全敏感"代码与普通代码，导致大量计算资源浪费在低价值路径上。

第二，**深层漏洞难以触及**。许多安全漏洞需要满足复杂的前置条件才能触发，例如特定的状态序列、精确的数值约束或特定的输入格式组合。纯粹基于变异的方法难以系统性地构造此类输入。

### 1.2 研究动机

大语言模型的出现为解决上述问题提供了新的可能。现代 LLM 具备强大的代码理解能力，能够：识别代码中的安全敏感模式、理解函数间的语义关系、推断触发漏洞所需的输入约束。

然而，直接将 LLM 应用于漏洞发现面临挑战。首先，大型代码库的规模远超 LLM 的上下文窗口限制。其次，LLM 的"幻觉"问题可能导致误报。最后，如何将 LLM 的分析结果转化为可验证的漏洞证明（POV）仍是开放问题。

### 1.3 本文贡献

本文提出 FuzzingBrain 系统，主要贡献包括：

1. **可疑点分析方法**：提出介于行级和函数级之间的漏洞粒度抽象，使 LLM 能够精确定位潜在漏洞位置并描述触发条件。

2. **两级函数池设计**：将目标代码库划分为小池（核心函数）和大池（全部可达函数），在有限预算下实现深度与广度的平衡。

3. **三阶段分析流程**：设计小池深度分析、大池广度覆盖、自由探索的递进式分析策略，确保关键代码得到充分审查。

4. **流水线并行架构**：实现可疑点发现、验证、POV 生成的并行流水线，显著提升分析效率。

---

## 2. 相关工作

### 2.1 传统模糊测试

模糊测试技术可追溯至 1988 年 Miller 等人的开创性工作。现代模糊测试器主要分为三类：

**变异型模糊测试**以 AFL 为代表，通过对种子输入进行随机变异生成测试用例，并利用覆盖率反馈指导变异方向。其优势在于通用性强，但在面对复杂输入格式时效率低下。

**生成型模糊测试**如 Peach、Domato 等，基于输入格式规范生成结构化测试用例。此类方法能够生成格式正确的输入，但需要人工编写语法规范。

**混合型模糊测试**将模糊测试与符号执行相结合，如 Driller、QSYM 等。这些工具利用符号执行求解路径约束以突破覆盖率瓶颈，但面临路径爆炸问题。

### 2.2 基于学习的漏洞发现

近年来，研究者尝试将机器学习应用于漏洞发现。早期工作如 VulDeePecker、Devign 等使用深度学习模型对代码进行漏洞分类，但这些方法仅能判断代码片段是否包含漏洞，无法生成具体的触发输入。

随着 LLM 的发展，研究者开始探索其在安全领域的应用。Fuzz4All 利用 LLM 生成多样化的测试输入；TitanFuzz 使用 LLM 指导模糊测试的变异策略；ChatAFL 将 LLM 集成到 AFL 的种子调度中。然而，这些工作主要将 LLM 作为辅助工具，未能充分发挥其代码理解能力。

### 2.3 程序分析与漏洞检测

静态分析工具如 Coverity、Infer、CodeQL 等通过数据流分析、污点追踪等技术检测潜在漏洞。这些工具能够覆盖全部代码路径，但误报率较高，且难以生成触发漏洞的具体输入。

动态分析工具如 Valgrind、AddressSanitizer 等在程序运行时检测内存错误。它们具有极低的误报率，但只能检测已执行路径上的问题。

FuzzingBrain 的独特之处在于将 LLM 的语义理解能力与动态验证相结合，既能进行全面的代码审查，又能生成经过验证的漏洞证明。

---

## 3. 系统概述

### 3.1 设计目标

FuzzingBrain 的设计遵循以下核心目标：

**准确性**：通过动态验证确保每个报告的漏洞都可复现，消除 LLM 幻觉导致的误报。

**完整性**：系统性覆盖目标代码库中的所有可达函数，避免遗漏深层漏洞。

**效率性**：通过并行化和智能调度，在有限时间和 API 成本预算内最大化分析效果。

**可解释性**：为每个发现的漏洞提供详细的分析报告，包括漏洞成因、触发路径和修复建议。

### 3.2 系统架构

FuzzingBrain 采用分层架构设计，自底向上分为四层：

**基础设施层**负责任务调度与状态管理。系统使用 Redis 作为消息队列，Celery 作为分布式任务执行框架，MongoDB 存储分析状态和结果。这一层支持任务的水平扩展，可在多节点集群上并行执行。

**分析服务层**提供代码分析能力。核心组件包括：基于 Tree-sitter 的多语言函数提取器、基于 OSS-Fuzz Introspector 的调用图构建器、基于 LLVM 的覆盖率收集器。该层通过 MCP（Model Context Protocol）协议向上层暴露工具接口。

**智能体层**是系统的核心，包含多个协作的 LLM 智能体：方向规划智能体负责宏观分析策略、函数分析智能体负责逐函数深度审查、可疑点验证智能体负责确认漏洞可行性、POV 生成智能体负责构造触发输入。

**应用层**提供用户交互接口，支持命令行、REST API、MCP 协议等多种访问方式。

### 3.3 核心概念

**可疑点（Suspicious Point, SP）**是 FuzzingBrain 引入的关键抽象。一个可疑点描述了代码中潜在的漏洞位置及其触发条件，包含以下信息：所在函数、漏洞类型、控制流描述、置信度评分。可疑点的粒度介于行级和函数级之间，既足够精确以指导 POV 生成，又足够抽象以容纳 LLM 的不确定性。

**方向（Direction）**是对代码库的逻辑划分。方向规划智能体根据调用图结构和代码语义，将相关函数聚类为若干方向，每个方向代表一个相对独立的功能模块。方向划分使得并行分析成为可能，同时为智能体提供了必要的上下文边界。

**函数池（Function Pool）**是待分析函数的组织结构。系统维护两级函数池：小池包含每个方向的核心函数和入口函数，是必须深度分析的高优先级目标；大池包含所有可达函数，在时间允许时尽量覆盖。

---

## 4. 可疑点分析方法

### 4.1 问题的提出

传统漏洞检测工具的输出粒度通常为行级（如静态分析器报告的具体行号）或函数级（如模糊测试发现的崩溃函数）。这两种粒度各有局限：

行级定位过于精确，当 LLM 对代码的理解存在细微偏差时，可能指向错误的位置。此外，许多漏洞（如条件竞争、逻辑错误）本质上是跨多行的，难以用单一行号描述。

函数级定位过于粗糙，一个包含数百行代码的函数中可能存在多个独立的安全问题，函数级输出无法区分它们。

### 4.2 可疑点的定义

可疑点是对潜在漏洞的结构化描述，包含以下要素：

**位置描述**：使用控制流路径而非绝对行号描述漏洞位置。例如，"在处理无效 XML 标签值的错误分支中"比"第 1024 行"更稳定、更具可读性。

**漏洞类型**：遵循 CWE（Common Weakness Enumeration）分类，标注潜在的漏洞类别，如堆缓冲区溢出（CWE-122）、释放后使用（CWE-416）等。

**触发条件**：描述触发该漏洞需要满足的输入约束或状态条件。

**置信度评分**：智能体对该可疑点确实为漏洞的主观概率估计，用于指导后续验证的优先级。

### 4.3 可疑点的生命周期

可疑点经历三个阶段的状态转换：

**创建阶段**：函数分析智能体在深度审查代码后，将发现的潜在问题封装为可疑点。此时可疑点处于"待验证"状态。

**验证阶段**：可疑点验证智能体结合静态分析结果（如调用路径、数据流）评估可疑点的可行性。验证通过后，状态更新为"已确认"，并调整置信度评分。

**证明阶段**：POV 生成智能体为已确认的可疑点构造触发输入。若输入成功触发目标 Sanitizer 报错，可疑点状态更新为"已证明"，同时生成正式的 POV 文件。

### 4.4 与现有方法的比较

与静态分析器相比，可疑点分析方法的优势在于：能够利用 LLM 的代码理解能力识别复杂的语义漏洞；通过动态验证消除误报；生成可执行的漏洞证明而非仅报告警告。

与纯模糊测试相比，可疑点分析方法的优势在于：分析是目标导向的而非随机的；能够识别需要特定输入序列才能触发的深层漏洞；对代码的覆盖是系统性的而非概率性的。

---

## 5. 两级函数池设计

### 5.1 设计动机

大型代码库可能包含数千个函数，在有限的分析预算（时间、API 调用次数、Token 消耗）下，必须对分析目标进行优先级排序。

朴素的方法是按代码复杂度或历史漏洞密度排序，但这忽视了函数间的语义关联。另一种方法是让智能体自由探索，但实验表明，这往往导致分析过于分散，关键函数得不到充分审查。

### 5.2 小池与大池

FuzzingBrain 将函数组织为两级池结构：

**小池（Small Pool）**包含每个分析方向的核心函数和入口函数。核心函数是方向规划智能体识别的最可能包含漏洞的函数；入口函数是模糊测试输入进入该方向的路径上的关键节点。小池的规模通常为 5 至 20 个函数，这些函数必须接受深度分析。

**大池（Big Pool）**包含目标模糊测试器可达的所有函数，通常为数百个。大池函数在小池分析完成后，按优先级依次分析。优先级的确定考虑两个因素：是否已被其他方向分析过、与已发现可疑点的代码距离。

### 5.3 优先级调度

系统维护一个全局的函数分析状态表，记录每个函数被哪些方向分析过。调度算法遵循以下优先级：

最高优先级分配给小池中从未被任何方向分析的函数。这确保方向规划智能体认为重要的函数优先得到审查。

次高优先级分配给小池中已被其他方向分析但未被当前方向分析的函数。不同方向代表不同的分析视角，可能发现前一轮遗漏的问题。

第三优先级分配给大池中从未被任何方向分析的函数。这些函数虽非核心，但可能包含被忽视的漏洞。

最低优先级分配给大池中已被其他方向分析的函数。仅在时间充裕时才分析这些函数。

### 5.4 覆盖率追踪

系统在分析过程中持续追踪覆盖率指标，包括：小池覆盖率（当前方向已分析的小池函数比例）、大池覆盖率（当前方向已分析的大池函数比例）、全局覆盖率（所有方向累计分析的函数比例）。

这些指标用于评估分析进度，并在分析结束时生成覆盖率报告。高质量的分析应实现小池覆盖率接近 100%，全局覆盖率尽可能高。

---

## 6. 三阶段分析流程

### 6.1 阶段划分

FuzzingBrain 的分析流程分为三个递进阶段：小池深度分析、大池广度分析、自由探索。每个阶段有不同的目标和策略。

### 6.2 第一阶段：小池深度分析

本阶段的目标是确保核心函数得到充分审查。对于小池中的每个函数，系统启动一个独立的函数分析智能体进行"主体分析"。

主体分析要求智能体：完整阅读函数源码、检查所有与目标 Sanitizer 相关的漏洞模式、追踪函数内的数据流和控制流、输出分析结论（创建可疑点或说明安全原因）。

每个函数分析智能体运行在独立的会话中，上下文仅包含当前函数及其直接调用关系。这种设计有两个好处：避免长上下文导致的 Token 累积、支持多函数并行分析。

对于超大函数（如超过 2000 行），系统启用滑动窗口机制和上下文压缩，确保智能体能够处理任意规模的函数。

### 6.3 第二阶段：大池广度分析

小池分析完成后，系统进入大池分析阶段。本阶段的目标是在剩余预算内最大化代码覆盖。

大池分析与小池分析使用相同的智能体和方法，区别在于：函数选择由优先级调度算法决定、分析可能因预算耗尽而提前终止、未分析的函数记录在报告中供后续审查。

### 6.4 第三阶段：自由探索

若前两阶段完成后仍有剩余预算，且发现的可疑点数量未达预期，系统进入自由探索阶段。

本阶段放松了逐函数分析的约束，允许智能体自主选择分析路径。典型行为包括：追踪已发现可疑点相关的调用链、寻找跨函数漏洞模式、快速浏览剩余未分析函数。

自由探索阶段使用配备上下文压缩的大型智能体，以便在单个会话中综合多个函数的信息。这一阶段的定位是兜底机制，用于发现结构化分析可能遗漏的问题。

### 6.5 阶段间的信息传递

三个阶段之间通过数据库共享状态。函数分析状态、已创建的可疑点、覆盖率统计等信息持久化存储，供后续阶段查询。

这种设计使得分析过程具有断点续传能力：若因外部原因中断，可从上次进度继续，无需重新开始。

---

## 7. 智能体协作架构

### 7.1 智能体类型

FuzzingBrain 包含四类智能体，各司其职：

**方向规划智能体（Direction Planning Agent）**负责宏观分析策略。它接收模糊测试器源码和可达函数统计信息，输出分析方向列表。每个方向包含：方向名称、风险等级、核心函数列表、入口函数列表、代码摘要。

**函数分析智能体（Function Analysis Agent）**负责逐函数深度审查。它接收单个函数的源码及其调用上下文，检查各类漏洞模式，输出可疑点或安全结论。系统根据函数规模选择标准版或大函数专用版智能体。

**可疑点验证智能体（Suspicious Point Verify Agent）**负责确认可疑点的可行性。它结合静态分析结果评估触发条件的可满足性，过滤明显不可行的可疑点，调整置信度评分。

**POV 生成智能体（POV Agent）**负责构造漏洞触发输入。它根据可疑点描述和函数源码，推断输入结构，生成候选 POV。POV 随后在目标模糊测试器上运行，成功触发 Sanitizer 报错则确认漏洞。

### 7.2 协作模式

智能体通过流水线架构协作。方向规划智能体率先执行，产出分析方向；函数分析智能体并行处理各方向的函数，产出可疑点；可疑点验证智能体实时消费新产生的可疑点，产出已确认可疑点；POV 生成智能体为高置信度可疑点构造触发输入。

流水线各阶段并行运行，无需等待前一阶段完全结束。这种设计显著缩短了端到端延迟：在函数分析进行中，已发现的可疑点即可进入验证和 POV 生成流程。

### 7.3 工具接口

智能体通过 MCP 协议调用分析工具。主要工具包括：

获取函数源码工具，支持按名称或行号范围查询函数内容；获取调用关系工具，返回指定函数的调用者和被调用者列表；获取覆盖率工具，运行指定输入并返回代码覆盖信息；创建可疑点工具，将分析发现的潜在漏洞记录到数据库；验证 POV 工具，在目标模糊测试器上运行候选输入并检查结果。

### 7.4 模型选择

不同智能体使用不同规模的语言模型。方向规划智能体使用最强模型，因为宏观策略的质量直接影响整体效果。函数分析智能体使用中等规模模型，在成本和能力间取得平衡。验证和 POV 生成智能体根据任务复杂度动态选择模型。

---

## 8. 分析服务器

### 8.1 设计目标

分析服务器（Analyzer Server）为智能体提供代码分析能力。设计目标包括：支持多语言代码的统一分析、提供毫秒级响应的查询接口、支持多智能体并发访问、与现有 OSS-Fuzz 基础设施兼容。

### 8.2 架构设计

分析服务器采用客户端-服务器架构。服务器进程在任务开始时启动，执行构建和静态分析，然后进入服务模式；客户端集成在各智能体中，通过 Unix 域套接字与服务器通信。

服务器内部包含三个核心模块：构建器负责编译目标项目并生成带 Sanitizer 的模糊测试器二进制文件；静态分析器负责提取函数定义、构建调用图、收集代码度量；查询引擎负责处理客户端请求并返回结果。

### 8.3 数据模型

分析服务器管理以下数据实体：

**函数（Function）**记录每个函数的元信息，包括名称、所在文件、起止行号、源码内容、复杂度指标、被分析状态。

**调用图节点（Callgraph Node）**记录函数间的调用关系，包括调用者、被调用者、调用位置。

**方向（Direction）**记录分析方向的定义和状态，包括名称、风险等级、核心函数、进度统计。

**可疑点（Suspicious Point）**记录发现的潜在漏洞，包括位置描述、漏洞类型、置信度、验证状态。

### 8.4 查询接口

分析服务器暴露以下查询接口：

获取可达函数列表：返回指定模糊测试器可达的所有函数名称及其基本信息。

获取函数源码：根据函数名或位置返回函数的完整源码，支持偏移量和长度参数以处理大函数。

获取调用关系：返回指定函数的调用者列表或被调用者列表。

获取函数统计：返回函数的复杂度指标、历史漏洞记录等辅助信息。

---

## 9. 执行策略

### 9.1 策略框架

FuzzingBrain 定义了策略抽象，封装不同场景下的分析流程。当前实现包括：全扫描 POV 策略、增量扫描 POV 策略、补丁生成策略。

策略决定了：启动哪些智能体、智能体间如何协作、分析预算如何分配、结果如何整合。

### 9.2 全扫描 POV 策略

全扫描策略用于对整个代码库进行系统性漏洞挖掘，是默认的分析策略。

执行流程如下：首先，方向规划智能体分析模糊测试器入口和调用图，划分分析方向；然后，系统为每个方向启动函数分析智能体池，执行三阶段分析流程；同时，验证和 POV 生成智能体并行处理产生的可疑点；最后，汇总所有已证明的可疑点，生成分析报告和 POV 文件。

### 9.3 增量扫描策略

增量扫描策略用于分析代码变更引入的漏洞，适合集成到持续集成流程。

与全扫描的区别在于：分析范围限定在变更函数及其受影响的调用链；方向划分基于变更影响分析而非完整调用图；优先级调度侧重变更相关函数。

### 9.4 并行流水线

无论采用何种策略，智能体均通过流水线并行执行。流水线包含三个池：

可疑点发现池（SP Find Pool）包含多个函数分析智能体，并行处理各方向的函数。池的大小可配置，默认为 5 个并发智能体。

验证池（Verify Pool）包含多个验证智能体，轮询数据库中新创建的可疑点并进行验证。

POV 生成池（POV Pool）包含多个 POV 生成智能体，为高置信度可疑点构造触发输入。

三个池通过数据库解耦，各自独立运行，实现最大程度的并行化。

---

## 10. 实现细节

### 10.1 系统组成

FuzzingBrain 的代码组织如下：

智能体模块实现各类 LLM 智能体，包括基础智能体类、方向规划智能体、函数分析智能体、可疑点验证智能体、POV 生成智能体。

分析服务器模块实现代码分析服务，包括服务器主程序、客户端库、构建器、数据模型。

工具模块实现 MCP 工具接口，包括代码查询工具、覆盖率工具、可疑点管理工具、方向管理工具。

工作器模块实现分布式任务执行，包括任务定义、执行器、策略实现、清理逻辑。

核心模块实现系统基础设施，包括配置管理、日志系统、数据模型、任务调度。

### 10.2 数据存储

系统使用 MongoDB 存储持久化数据。主要集合包括：

任务集合记录分析任务的元信息和状态；工作器集合记录每个工作器的执行状态和结果；函数集合记录提取的函数信息；方向集合记录分析方向定义；可疑点集合记录发现的潜在漏洞；POV 集合记录生成的漏洞证明。

### 10.3 任务调度

系统使用 Celery 实现分布式任务调度。每个模糊测试器和 Sanitizer 的组合对应一个工作器任务。工作器任务可分布到多个计算节点执行，通过 Redis 消息队列协调。

### 10.4 缓存机制

为避免重复构建，系统实现了工作空间缓存。缓存键由项目名、提交哈希、Sanitizer 配置组成。命中缓存时，系统跳过构建步骤，直接恢复已构建的二进制文件和静态分析数据。

---

## 11. 讨论

### 11.1 与传统模糊测试的关系

FuzzingBrain 不是要取代传统模糊测试，而是与之互补。传统模糊测试擅长发现输入处理逻辑中的简单漏洞，FuzzingBrain 则擅长发现需要语义理解的复杂漏洞。

在实践中，建议将两者结合使用：先运行传统模糊测试以快速发现低垂果实，再使用 FuzzingBrain 深入挖掘剩余漏洞。

### 11.2 成本考量

LLM API 调用带来显著的运行成本。系统通过以下方式控制成本：优先使用小规模模型处理简单任务、缓存构建结果避免重复分析、支持预算限制和提前终止。

尽管如此，对大型代码库的全面分析仍需可观的 API 预算。在资源受限场景下，建议采用增量扫描策略，仅分析变更相关代码。

### 11.3 局限性

当前系统存在以下局限：

首先，分析质量依赖 LLM 的代码理解能力。对于使用不常见语言或框架的代码，LLM 可能无法准确识别漏洞模式。

其次，POV 生成的成功率有待提高。部分已确认的可疑点因输入构造困难而未能生成有效 POV。

最后，系统当前主要针对内存安全漏洞（由 Sanitizer 检测），对逻辑漏洞的支持尚不完善。

### 11.4 未来工作

未来工作方向包括：支持更多编程语言和漏洞类型、集成符号执行以辅助 POV 生成、开发交互式分析模式以支持人机协作、优化智能体提示词以提升分析质量。

---

## 12. 结论

本文介绍了 FuzzingBrain，一个基于大语言模型的自动化漏洞发现系统。通过引入可疑点抽象、两级函数池设计和三阶段分析流程，系统实现了对大型代码库的系统性漏洞挖掘。流水线并行架构使得分析过程高效运行，动态验证机制确保输出结果的可靠性。

FuzzingBrain 代表了将 LLM 应用于安全领域的一种有效范式：LLM 负责语义理解和假设生成，传统工具负责验证和执行。这种组合充分发挥了各自优势，为自动化漏洞发现开辟了新的可能。

---

## 附录 A：术语表

| 术语 | 英文 | 定义 |
|------|------|------|
| 可疑点 | Suspicious Point (SP) | 代码中潜在漏洞的结构化描述 |
| 方向 | Direction | 代码库的逻辑划分单元 |
| 小池 | Small Pool | 核心函数和入口函数的集合 |
| 大池 | Big Pool | 所有可达函数的集合 |
| POV | Proof-of-Vulnerability | 能够触发漏洞的输入证明 |
| 主体分析 | Subject Analysis | 以某函数为焦点的深度审查 |
| MCP | Model Context Protocol | LLM 工具调用的标准协议 |

---

## 附录 B：配置参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| 并行函数分析智能体数 | 5 | SP Find Pool 的大小 |
| 并行验证智能体数 | 5 | Verify Pool 的大小 |
| 并行 POV 生成智能体数 | 5 | POV Pool 的大小 |
| 函数分析最大迭代次数 | 3 | 单函数分析的最大轮次 |
| 大函数阈值 | 2000 行 | 触发大函数特殊处理的行数 |
| POV 最低置信度阈值 | 0.5 | 进入 POV 生成的最低分数 |
| 轮询间隔 | 2 秒 | 流水线池的轮询周期 |

---

*文档版本：v2.0*
*最后更新：2025年1月*
