# SP Find 架构 v2：逐函数深度分析

## 背景与问题

### 问题发现

在分析 libxml2 挑战（vuln_002：`xmlParseAttribute2` 中的 double-free）时，我们发现了 v1 SP Find 方案的关键缺陷。

**核心观察**：Agent 在整个会话中读取了 `xmlParseAttribute2` 5 次，但从未**将其作为主体进行分析**。每次都只是在分析其他内容时顺带看一眼：
- "让我看看其他更关键的函数..."
- 为了理解其他函数的上下文而简单读取
- 从未对这个特定函数进行深入的漏洞分析

**验证测试**：当我们提示模型**将 `xmlParseAttribute2` 作为主体进行分析**时，它成功识别出了 double-free 漏洞模式：
```
代码存在 double-free 漏洞：
1. 第一次 free 在第 9024 行：当 xml:tab 值无效时 xmlFree(internal_val)
2. 第二次 free 在第 9028 行：如果 internal_val 不为 NULL，无条件 xmlFree(internal_val)
当提供无效的 xml:tab 值时，internal_val 会被释放两次。
```

### 根本原因

v1 方案给了 Agent 太多探索自由：
- Agent 快速扫描以最大化覆盖率
- 每个函数只花几秒钟
- 还没深入分析就继续前进
- 真正的漏洞需要专注、持续的分析

---

## 两级函数池设计

### 函数池定义

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  大池（Big Pool）：该 fuzzer 所有可达函数                         │
│  来源：静态分析 / introspector                                   │
│  规模：可能几百个函数                                             │
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                                                         │   │
│  │  小池（Small Pool）：core_functions + entry_functions   │   │
│  │  来源：Direction Planning Agent 识别的重点函数           │   │
│  │  规模：通常 5-20 个函数                                  │   │
│  │                                                         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 小池（Small Pool）

**定义**：Direction Planning Agent 在方向规划阶段识别出的重点函数

**组成**：
- `core_functions`：该方向的核心函数，最可能包含漏洞
- `entry_functions`：fuzzer 输入如何进入该方向的入口函数

**特点**：
- 数量较少（通常 5-20 个）
- 由 LLM 根据代码语义识别，质量较高
- 必须全部深度分析

### 大池（Big Pool）

**定义**：该 fuzzer 可达的所有函数

**来源**：静态分析 / OSS-Fuzz introspector

**特点**：
- 数量较多（可能几百个）
- 包含小池函数 + 其他所有可达函数
- 尽可能覆盖，但不强制全部分析

---

## 三阶段分析流程

### 流程概览

```
┌─────────────────────────────────────────────────────────────────┐
│                     SP Find Agent 分析流程                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  阶段一：小池深度分析                                             │
│  ├── 目标：core_functions + entry_functions                     │
│  ├── 方式：逐函数深度分析（作为主体）                              │
│  ├── Agent：每个函数一个独立小 Agent                              │
│  ├── 优先级：未被任何方向分析 > 未被当前方向分析                    │
│  └── 必须完成：是                                                │
│                                                                 │
│                          ↓                                      │
│                                                                 │
│  阶段二：大池深度分析                                             │
│  ├── 目标：大池中尚未分析的函数                                   │
│  ├── 方式：逐函数深度分析（作为主体）                              │
│  ├── Agent：每个函数一个独立小 Agent                              │
│  ├── 优先级：未被任何方向分析 > 未被当前方向分析                    │
│  └── 必须完成：否（时间/迭代允许的情况下尽量覆盖）                  │
│                                                                 │
│                          ↓                                      │
│                                                                 │
│  阶段三：自由探索（兜底）                                         │
│  ├── 目标：补充发现、调用链追踪                                   │
│  ├── 方式：自由探索，快速扫描                                     │
│  ├── Agent：一个大 Agent（带 Context Compression）               │
│  ├── 内容：                                                     │
│  │   ├── 追踪调用链，发现跨函数漏洞                               │
│  │   ├── 快速浏览剩余未覆盖函数                                   │
│  │   └── 基于已发现问题深入挖掘                                   │
│  └── 必须完成：否（作为兜底机制）                                  │
│                                                                 │
│                          ↓                                      │
│                                                                 │
│  结束：统计覆盖率                                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Agent 架构：小 Agent vs 大 Agent

**为什么阶段一二用小 Agent（每函数独立 session）**：

```
┌─────────────────────────────────────────────────────────────────┐
│  大 Agent 问题（一个 session 分析多个函数）                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  函数 1 分析... (上下文: 系统提示 + 函数1)                         │
│       ↓                                                         │
│  函数 2 分析... (上下文: 系统提示 + 函数1历史 + 函数2)              │
│       ↓                                                         │
│  函数 3 分析... (上下文: 系统提示 + 函数1历史 + 函数2历史 + 函数3)   │
│       ↓                                                         │
│  ...上下文越来越长，Token 成本累积                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  小 Agent 方案（每个函数独立 session）                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  函数 1 → Agent Session 1 (短上下文) → 结束，释放                  │
│  函数 2 → Agent Session 2 (短上下文) → 结束，释放                  │
│  函数 3 → Agent Session 3 (短上下文) → 结束，释放                  │
│  ...每个 session 上下文独立，不累积                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**小 Agent 优势**：
- **Token 节省**：每个 session 上下文只有当前函数，不累积历史
- **可并行**：多个小 Agent 可以同时运行
- **失败隔离**：一个函数分析失败不影响其他
- **专注**：每个 Agent 只关注一个函数，分析更深入

**小 Agent 上下文结构**：
```
系统提示（sanitizer 相关漏洞模式）
+
当前函数源码
+
caller name list（调用当前函数的函数名列表）
+
callee name list（被当前函数调用的函数名列表）
```

注意：caller/callee 只是函数名列表，不是源码，占用空间很小。Agent 需要看具体源码时用 `get_function_source` 工具查询。

**小 Agent 迭代次数**：
- 普通函数：3 次迭代
- MCP Agent 一次能处理大量上下文，3 次足够完成深度分析

**小 Agent 目标**：
```
分析函数
    ↓
发现问题 → 调用 create_suspicious_point()
没发现   → 结束
```

### 大函数处理

**问题**：有些函数可能 3000+ 行，需要特殊处理

**方案**：小 Agent 只是"分析对象小"，不是"context window 小"

```
检测函数大小
    ↓
┌─────────────────────────────────────────┐
│  普通函数（< 2000 行）                    │
│  ├── 迭代次数：3 次                       │
│  ├── 上下文：完整函数源码                  │
│  └── 不需要压缩                          │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│  大函数（> 2000 行）                      │
│  ├── 迭代次数：更多（5-10 次）            │
│  ├── 启用 Context Compression            │
│  ├── 滑动窗口逐段阅读                     │
│  └── 压缩保留已分析部分的关键发现          │
└─────────────────────────────────────────┘
```

**滑动窗口**：Agent 可以用 `get_function_source(name, offset, limit)` 分段读取大函数，确保能看到完整内容。

**为什么阶段三用大 Agent（带 Context Compression）**：

自由探索需要跨函数分析，需要保持上下文连贯：
- 追踪调用链需要记住之前看过的函数
- 发现关联问题需要综合多个函数的信息
- 使用 Context Compression 控制上下文长度

**大 Agent 配置**：
- 启用 Context Compression
- 定期压缩历史对话
- 保留关键发现和当前分析状态

### 阶段一：小池深度分析

**目标**：确保 Direction Agent 识别的重点函数都被深度分析

**函数来源**：
- `core_functions`：方向的核心函数列表
- `entry_functions`：方向的入口函数列表

**分析方式**：逐函数深度分析
- 每个函数作为**主体**进行分析
- Agent 必须阅读整个函数体
- 必须检查所有 sanitizer 相关的漏洞模式
- 必须考虑数据流和控制流

**优先级排序**：
1. **最高优先**：在小池中 + 未被任何方向分析过
2. **次高优先**：在小池中 + 未被当前方向分析过（但被其他方向分析过）

**完成条件**：小池中所有函数都被当前方向分析过

### 阶段二：大池深度分析

**目标**：扩大覆盖范围，分析更多可达函数

**函数来源**：大池中尚未被当前方向分析的函数（排除阶段一已分析的）

**分析方式**：逐函数深度分析（与阶段一相同）

**优先级排序**：
1. **最高优先**：未被任何方向分析过（全新函数）
2. **次高优先**：未被当前方向分析过

**为什么优先"未被任何方向分析"**：
- 引导 Agent 看"完全没看过的代码"
- 最大化整体覆盖率
- 避免多个方向重复分析相同函数

**继续条件**：
- 还有时间/预算剩余
- 还有未分析的函数

**停止条件**：
- 时间用完
- 预算用完（Token/API 调用次数）
- 大池函数全部分析完毕

### 阶段三：自由探索（兜底）

**目标**：灵活补充，发现阶段一二可能遗漏的问题

**触发条件**：阶段一二完成后，仍有迭代次数剩余

**分析方式**：自由探索（类似 v1 模式）
- 不强制逐函数分析
- Agent 可以自由选择分析路径
- 可以快速扫描多个函数

**典型行为**：
- 追踪在阶段一二发现的可疑调用链
- 寻找跨函数漏洞模式
- 快速浏览剩余未覆盖函数
- 基于已创建的 SP 深入挖掘相关代码

**为什么需要这个阶段**：
- 阶段一二是"强制"的，可能过于机械
- 有些漏洞需要跨函数分析才能发现
- 给 Agent 一定的自由度，发挥其创造性
- 作为兜底机制，确保不会因为过于结构化而遗漏问题

---

## 函数优先级详解

### 优先级矩阵

```
优先级 = 池归属 × 分析状态

┌──────────────────────────────────────────────────────────────────┐
│                        分析状态                                   │
│              ┌─────────────────┬─────────────────┐               │
│              │ 未被任何方向分析 │ 仅未被当前方向分析│               │
├──────────────┼─────────────────┼─────────────────┤               │
│ 池   小池    │   优先级 1      │   优先级 2      │               │
│ 归           │   (最高)        │   (次高)        │               │
│ 属  ─────────┼─────────────────┼─────────────────┤               │
│     大池     │   优先级 3      │   优先级 4      │               │
│              │                 │   (最低)        │               │
└──────────────┴─────────────────┴─────────────────┘               │
```

### 优先级 1：小池 + 未被任何方向分析

**特征**：
- Direction Agent 认为重要的函数
- 完全没有被任何方向看过
- 最可能包含未发现的漏洞

**处理**：立即深度分析

### 优先级 2：小池 + 仅未被当前方向分析

**特征**：
- Direction Agent 认为重要的函数
- 被其他方向分析过，但当前方向还没看
- 不同方向可能有不同视角，仍需分析

**处理**：深度分析（可能发现其他方向遗漏的问题）

### 优先级 3：大池 + 未被任何方向分析

**特征**：
- 不在当前方向的核心函数列表中
- 但从未被任何方向分析过
- 可能是被忽视的角落

**处理**：在时间允许的情况下深度分析

### 优先级 4：大池 + 仅未被当前方向分析

**特征**：
- 不在当前方向的核心函数列表中
- 且已被其他方向分析过
- 优先级最低

**处理**：时间充裕时才分析，或在自由探索阶段快速扫描

---

## 追踪机制

### 追踪字段

每个函数记录哪些方向已经分析过它：

```
Function:
  - function_id: "{task_id}_{function_name}"
  - name: "xmlParseAttribute2"
  - analyzed_by_directions: ["direction_abc123", "direction_def456"]
  - ...
```

### 标记时机

**何时标记为"已分析"**：
- 在阶段一或阶段二中，Agent 完成对该函数的深度分析后
- 不是简单读取，而是作为主体进行完整分析

**何时不标记**：
- 阶段三自由探索中的快速浏览不标记
- 为了理解上下文而简单读取不标记
- 只有"深度分析"才标记

### 标记操作

使用 MongoDB 原子操作防止并发问题：
```
$addToSet: {"analyzed_by_directions": direction_id}
```

### 查询操作

**获取优先级 1 函数（小池 + 全新）**：
```
查询条件：
- name 在 [core_functions + entry_functions] 中
- analyzed_by_directions 为空数组
```

**获取优先级 2 函数（小池 + 未被当前方向分析）**：
```
查询条件：
- name 在 [core_functions + entry_functions] 中
- analyzed_by_directions 不包含 current_direction_id
- analyzed_by_directions 不为空（被其他方向分析过）
```

**获取优先级 3 函数（大池 + 全新）**：
```
查询条件：
- name 不在小池中
- analyzed_by_directions 为空数组
```

---

## 覆盖率统计

### 统计时机

每个方向的 SP Find Agent 结束时，统计覆盖率

### 统计指标

**小池覆盖率**：
```
小池覆盖率 = 当前方向分析的小池函数数 / 小池函数总数

示例：
- 小池有 15 个函数
- 当前方向分析了 15 个
- 覆盖率 = 100%
```

**大池覆盖率**：
```
大池覆盖率 = 当前方向分析的大池函数数 / 大池函数总数

示例：
- 大池有 200 个函数
- 当前方向分析了 45 个
- 覆盖率 = 22.5%
```

**全局覆盖率（跨所有方向）**：
```
全局覆盖率 = 被至少一个方向分析的函数数 / 大池函数总数

示例：
- 大池有 200 个函数
- 被至少一个方向分析的有 120 个
- 全局覆盖率 = 60%
```

### 统计报告

每个方向结束时生成报告：

```
┌─────────────────────────────────────────────────────────────────┐
│                    方向分析覆盖率报告                             │
├─────────────────────────────────────────────────────────────────┤
│  方向：XML Document Parsing Core                                 │
│  方向 ID：direction_abc123                                       │
├─────────────────────────────────────────────────────────────────┤
│  小池覆盖率                                                      │
│  ├── 小池函数总数：15                                            │
│  ├── 当前方向分析：15                                            │
│  └── 覆盖率：100%                                                │
├─────────────────────────────────────────────────────────────────┤
│  大池覆盖率                                                      │
│  ├── 大池函数总数：200                                           │
│  ├── 当前方向分析：45                                            │
│  └── 覆盖率：22.5%                                               │
├─────────────────────────────────────────────────────────────────┤
│  全局覆盖率（所有方向累计）                                       │
│  ├── 大池函数总数：200                                           │
│  ├── 至少被一个方向分析：120                                      │
│  └── 覆盖率：60%                                                 │
├─────────────────────────────────────────────────────────────────┤
│  SP 发现                                                         │
│  ├── 本方向创建 SP 数：8                                         │
│  └── 其中高置信度（>0.7）：3                                      │
└─────────────────────────────────────────────────────────────────┘
```

---

## "主体分析"的定义

### 什么是主体分析

**主体分析**是指将某个函数作为分析的**首要焦点**，进行深入、完整的漏洞分析。

### 主体分析的要求

1. **完整阅读**：读取整个函数体，不是只看片段
2. **逐模式检查**：对每种 sanitizer 相关的漏洞模式进行检查
3. **数据流分析**：追踪输入如何流经该函数
4. **控制流分析**：检查分支条件、错误处理路径
5. **输出结论**：要么创建 SP，要么明确说明为什么安全

### 主体分析的提示词结构

```
你正在将 {function_name} 作为主体进行分析。

## 函数信息

- 函数名：{function_name}
- 文件：{file_path}
- 行数：{start_line} - {end_line}

## 函数源码

{function_source_code}

## 你的任务

对这个函数进行深度安全漏洞分析。

### 必须检查的漏洞模式

（根据 sanitizer 类型列出）

对于 AddressSanitizer：
1. Buffer overflow / Out-of-bounds access
2. Use-after-free
3. Double-free
4. Stack buffer overflow
5. Heap buffer overflow

对于 MemorySanitizer：
1. Uninitialized memory read
2. Information leak

### 分析步骤

1. 仔细阅读整个函数
2. 识别所有内存操作（malloc/free/memcpy/数组访问等）
3. 追踪数据流：输入如何影响这些操作
4. 检查边界条件和错误处理
5. 寻找可能绕过安全检查的路径

### 输出要求

**如果发现可疑点**：
- 描述漏洞模式（用控制流描述，不用行号）
- 解释触发条件
- 调用 create_suspicious_point 创建 SP

**如果未发现问题**：
- 解释为什么这个函数是安全的
- 说明你检查了哪些模式
```

### 非主体分析（不标记）

以下情况不算"主体分析"，不标记 analyzed_by_directions：

- 为了理解调用上下文而简单读取
- 在自由探索阶段快速浏览
- 作为其他函数分析的辅助信息
- 只读取了函数的一部分

---

## 为什么用方向级追踪

### 不同方向 = 不同上下文

同一函数可能与多个方向相关：
- 方向 A："内存管理" - 关注 UAF、double-free
- 方向 B："输入解析" - 关注 buffer overflow
- 方向 C："字符串处理" - 关注 format string

每个方向带来：
- 不同的心智模型
- 不同的入口点理解
- 不同的漏洞模式关注

### 为什么不用全局 `analyzed: bool`

全局标志的问题：
1. 第一个方向分析函数后，标记为 true
2. 后续方向全部跳过
3. 不同上下文可见的 bug 被遗漏

### 为什么不用 fuzzer 级追踪

fuzzer 级太粗粒度：
- 一个 fuzzer 可能有 5+ 个方向
- 同一函数在不同方向需要不同视角分析

### 为什么不限制"每个函数最多被 N 个方向分析"

不限制的原因：
- 优先级机制已经自然引导 Agent 看新函数
- "未被任何方向分析"的优先级最高
- 只有在新函数都看完后，才会分析"被其他方向看过"的

---

## 预期行为示例

### 场景：libxml2 with 3 个方向

**设置**：
- 大池：200 个可达函数
- 方向 1：XML Parsing Core（小池 15 个函数，包含 xmlParseAttribute2）
- 方向 2：Memory Management（小池 10 个函数）
- 方向 3：Error Handling（小池 8 个函数）

**方向 1 执行**：

```
阶段一：小池深度分析
├── 15 个小池函数全部是优先级 1（未被任何方向分析）
├── 逐个深度分析
├── 分析 xmlParseAttribute2 时发现 double-free
├── 创建 SP，score 0.85
└── 标记：所有 15 个函数的 analyzed_by_directions = ["direction_1"]

阶段二：大池深度分析
├── 还剩 185 个大池函数（都是优先级 3：未被任何方向分析）
├── 按优先级逐个分析
├── 分析了 30 个后迭代次数用完
└── 标记：这 30 个函数的 analyzed_by_directions = ["direction_1"]

阶段三：自由探索
└── 迭代次数已用完，跳过

覆盖率报告：
├── 小池覆盖率：100%（15/15）
├── 大池覆盖率：22.5%（45/200）
└── 全局覆盖率：22.5%（45/200）
```

**方向 2 执行**：

```
阶段一：小池深度分析
├── 10 个小池函数中：
│   ├── 7 个是优先级 1（未被任何方向分析）
│   └── 3 个是优先级 2（被方向 1 分析过，但有重叠）
├── 优先分析 7 个全新的
├── 然后分析 3 个重叠的
└── 标记完成

阶段二：大池深度分析
├── 大池中还有 148 个未被任何方向分析（优先级 3）
├── 按优先级分析
└── 分析了 25 个后迭代次数用完

覆盖率报告：
├── 小池覆盖率：100%（10/10）
├── 大池覆盖率：17.5%（35/200）
└── 全局覆盖率：40%（80/200）
```

**方向 3 执行后**：

```
最终全局覆盖率报告：
├── 大池函数总数：200
├── 被至少一个方向分析：120
├── 全局覆盖率：60%
└── 未覆盖函数列表：[func_a, func_b, ...]
```

---

## 总结

| 方面 | v1 | v2 |
|------|-----|-----|
| 函数池 | 无明确划分 | 两级池（小池 + 大池） |
| 分析流程 | 仅自由探索 | 三阶段（小池 → 大池 → 自由探索） |
| 优先级 | 无 | 四级优先级矩阵 |
| 覆盖保证 | 尽力而为 | 小池 100%，大池尽量覆盖 |
| 分析深度 | 浅（快速扫描） | 深（主体分析） |
| 追踪 | 无 | `analyzed_by_directions` |
| 覆盖率统计 | 无 | 小池/大池/全局三级统计 |
| 兜底机制 | 无 | 自由探索阶段 |

---

## 版本历史

- v0.0.1：初始实现（仅自由探索）
- v0.0.2：两阶段分析，含逐函数深度分析
- v0.0.3：两级函数池 + 三阶段分析 + 覆盖率统计
- v0.0.4：小 Agent 架构（每函数独立 session）+ 大函数处理 + 停止条件细化
